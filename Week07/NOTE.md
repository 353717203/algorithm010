学习笔记
====
## 一、学习内容
### 字典树
 * 字典树，即Trie树，典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计
 * 优点：最大限度地减少所谓的字符串比较，查询效率比哈希表高
 
 * 基本性质：
  * 1、节点本身不存完整单词
  * 2、从根节点到某一结点，路径上经过的路径连起来，为该节点对应的字符串
  * 3、每个节点的所有子节点路径代表的字符都不相同
  
 * 核心思想：
  * Tried树是空间换时间
  * 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的
 
### 并查集
 * 基本操作：
  * 1、makeSet(s)：建立并查集，其中包含s个单元素集合
  * 2、unionSet(x, y)：把元素x和元素y所在的集合合并（x所在集合和y所在集合不相交，如果相交则不合并）
  * 3、find(x)：找到元素x所在的集合的代表，也可用于判断两个元素是否在同一个集合
  
### 红黑树
 * 每个节点或者是黑色，或者是红色。
 * 根节点是黑色。
 * 每个叶子节点（NIL）是黑色 （叶子节点是指为空(NIL或NULL)的叶子节点）
 * 如果一个节点是红色的，则它的子节点必须是黑色的。
 * 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点
 
### AVL树
 * 本身首先是一棵二叉搜索树。
 * 带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）

## 二、习题总结
 ### 单词搜索时间复杂度：O(m * n * (4 * 3 ^ (length - 1))
  * 1、对二维网格board中每个单词进行遍历，因此该处的时间复杂度为m * n（board的行*列）
  * 2、对遍历的每个单词进行回溯算法判断是否出现在单词列表中（单词列表中最长单词数为length），在回溯算法中，每个单词起始可以往4个方向走，因为同一个单元格内字母不会出现在一个单词，因此往后每个单词只能向剩下的3个方向走，即3^(length - 1)的时间复杂度
  * 3、对于整个算法而言，总时间复杂度就是遍历board每个单词的时间复杂度乘上回溯算法的复杂度，为
 
 ### 双向BFS模板
  left, right = [beginWord], [endWord]
        alph_list = list('abcdefghijklmnopqrstuvwxyz')
        step = 1
        while left:
            mid = set()
            for word in left:
                for i in range(len(beginWord)):
                    for c in alph_list:
                        new = word[:i] + c + word[i+1:]
                        if new in right:
                            return step + 1
                        if new in wordList:
                            mid.add(new)
                            wordList.remove(new)
            left = mid
            step += 1
            if len(left) > len(right):
                left, right = right, left
